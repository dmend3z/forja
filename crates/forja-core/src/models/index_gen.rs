use std::fs;
use std::path::Path;

use crate::error::Result;
use crate::models::decision;
use crate::models::run_log;
use crate::models::spec;
use crate::models::track;
use crate::models::vision;

/// Generate INDEX.md from all .forja/ files.
pub fn generate_index(forja_dir: &Path) -> Result<String> {
    let mut out = String::new();
    let now = chrono::Utc::now().to_rfc3339();

    out.push_str("# Project Index\n");
    out.push_str("> Auto-generated by forja. Do not edit.\n");
    out.push_str(&format!("> Last updated: {now}\n\n"));

    // Vision
    let vision_path = forja_dir.join("docs").join("vision.md");
    if vision_path.exists()
        && let Ok(v) = vision::load_vision(&vision_path) {
            out.push_str("## Vision\n");
            out.push_str(&format!("- **Project:** {}\n", v.project()));
            if let Some(ref stack) = v.frontmatter.tech_stack {
                let mut parts = Vec::new();
                if let Some(ref lang) = stack.language {
                    parts.push(lang.as_str());
                }
                if let Some(ref fw) = stack.framework {
                    parts.push(fw.as_str());
                }
                if !parts.is_empty() {
                    out.push_str(&format!("- **Stack:** {}\n", parts.join(" + ")));
                }
            }
            out.push('\n');
        }

    // Tracks
    let tracks = track::discover_tracks(&forja_dir.join("tracks")).unwrap_or_default();
    if !tracks.is_empty() {
        out.push_str("## Tracks\n");
        out.push_str("| Track | Status | Progress |\n");
        out.push_str("|-------|--------|----------|\n");
        for t in &tracks {
            let (done, total) = t.progress();
            out.push_str(&format!(
                "| {} | {} | {}/{} done |\n",
                t.title(),
                t.frontmatter.status.as_str(),
                done,
                total,
            ));
        }
        out.push('\n');
    }

    // Specs
    let specs_dir = forja_dir.join("specs");
    let specs = if specs_dir.exists() {
        spec::discover_specs(&specs_dir).unwrap_or_default()
    } else {
        Vec::new()
    };
    if !specs.is_empty() {
        out.push_str("## Specs\n");
        out.push_str("| ID | Title | Status | Track | Priority |\n");
        out.push_str("|----|-------|--------|-------|----------|\n");
        for s in &specs {
            out.push_str(&format!(
                "| {} | {} | {} | {} | {} |\n",
                s.id(),
                s.title(),
                s.status.as_str(),
                s.frontmatter.track.as_deref().unwrap_or("-"),
                s.frontmatter.priority.as_deref().unwrap_or("-"),
            ));
        }
        out.push('\n');
    }

    // Decisions
    let decisions = decision::discover_decisions(&forja_dir.join("decisions")).unwrap_or_default();
    if !decisions.is_empty() {
        out.push_str("## Decisions\n");
        out.push_str("| ID | Title | Status | Date |\n");
        out.push_str("|----|-------|--------|------|\n");
        for d in &decisions {
            out.push_str(&format!(
                "| {} | {} | {} | {} |\n",
                d.id(),
                d.title(),
                d.frontmatter.status.as_str(),
                d.frontmatter.date,
            ));
        }
        out.push('\n');
    }

    // Recent runs
    let runs = run_log::discover_runs(&forja_dir.join("runs")).unwrap_or_default();
    if !runs.is_empty() {
        out.push_str("## Recent Runs\n");
        out.push_str("| Spec | Agent | Status | Date |\n");
        out.push_str("|------|-------|--------|------|\n");
        // Show at most 10 recent runs
        for run in runs.iter().take(10) {
            let date = run
                .frontmatter
                .started_at
                .split('T')
                .next()
                .unwrap_or(&run.frontmatter.started_at);
            out.push_str(&format!(
                "| {} | {} | {} | {} |\n",
                run.spec_id(),
                run.frontmatter.agent,
                run.frontmatter.status.as_str(),
                date,
            ));
        }
        out.push('\n');
    }

    Ok(out)
}

/// Write INDEX.md to .forja/INDEX.md.
pub fn write_index(forja_dir: &Path) -> Result<()> {
    let content = generate_index(forja_dir)?;
    fs::write(forja_dir.join("INDEX.md"), content)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_forja() -> tempfile::TempDir {
        let dir = tempfile::tempdir().unwrap();
        let forja = dir.path();
        fs::create_dir_all(forja.join("docs")).unwrap();
        fs::create_dir_all(forja.join("tracks")).unwrap();
        fs::create_dir_all(forja.join("specs")).unwrap();
        fs::create_dir_all(forja.join("decisions")).unwrap();
        fs::create_dir_all(forja.join("runs")).unwrap();

        fs::write(
            forja.join("docs").join("vision.md"),
            "---\nproject: Test App\ndescription: A test\ntech_stack:\n  language: Rust\n  framework: Axum\n---\n# Vision\n",
        ).unwrap();

        fs::write(
            forja.join("tracks").join("track-mvp.md"),
            "---\nid: mvp\ntitle: MVP\ndescription: D\nstatus: in-progress\ncreated: \"2026-01-01\"\n---\n| ID | Task | Status | Spec |\n|---|---|---|---|\n| M1 | Auth | done | auth |\n| M2 | API | todo | api |\n",
        ).unwrap();

        fs::write(
            forja.join("specs").join("auth.md"),
            "---\nid: auth\ntitle: Auth\ndescription: D\nstatus: done\ntrack: mvp\npriority: high\n---\n",
        ).unwrap();

        fs::write(
            forja.join("decisions").join("001.md"),
            "---\nid: \"001\"\ntitle: JWT Strategy\nstatus: accepted\ndate: \"2026-02-18\"\n---\nBody.",
        ).unwrap();

        dir
    }

    #[test]
    fn generate_index_includes_all_sections() {
        let dir = setup_forja();
        let index = generate_index(dir.path()).unwrap();

        assert!(index.contains("# Project Index"));
        assert!(index.contains("Auto-generated by forja"));
        assert!(index.contains("## Vision"));
        assert!(index.contains("**Project:** Test App"));
        assert!(index.contains("**Stack:** Rust + Axum"));
        assert!(index.contains("## Tracks"));
        assert!(index.contains("MVP"));
        assert!(index.contains("1/2 done"));
        assert!(index.contains("## Specs"));
        assert!(index.contains("auth"));
        assert!(index.contains("## Decisions"));
        assert!(index.contains("JWT Strategy"));
    }

    #[test]
    fn write_index_creates_file() {
        let dir = setup_forja();
        write_index(dir.path()).unwrap();

        let path = dir.path().join("INDEX.md");
        assert!(path.exists());
        let content = fs::read_to_string(path).unwrap();
        assert!(content.contains("# Project Index"));
    }

    #[test]
    fn empty_project_produces_minimal_index() {
        let dir = tempfile::tempdir().unwrap();
        fs::create_dir_all(dir.path().join("docs")).unwrap();
        let index = generate_index(dir.path()).unwrap();
        assert!(index.contains("# Project Index"));
        assert!(!index.contains("## Tracks"));
    }
}
